from abc import abstractproperty

from ..hdl import *
from ..lib.cdc import ResetSynchronizer
from ..build import *


__all__ = ["GowinGW1NPlatform"]


class GowinGW1NPlatform(TemplatedPlatform):
    """
    Apicula toolchain
    ------------------

    Required tools:
        * ``yosys``
        * ``nextpnr-generic``
        * ``apicula``

    The environment is populated by running the script specified in the environment variable
    ``NMIGEN_ENV_Apicula``, if present.

    Available overrides:
        * ``verbose``: enables logging of informational messages to standard error.
        * ``read_verilog_opts``: adds options for ``read_verilog`` Yosys command.
        * ``synth_opts``: adds options for ``synth_xxxx`` Yosys command.
        * ``script_after_read``: inserts commands after ``read_ilang`` in Yosys script.
        * ``script_after_synth``: inserts commands after ``synth_xxxxx`` in Yosys script.
        * ``yosys_opts``: adds extra options for ``yosys``.
        * ``nextpnr_opts``: adds extra options for ``nextpnr-generic``.
        * ``add_pre_pack``: inserts commands at the end in pre-pack Python script.
        * ``add_constraints``: inserts commands at the end in the PCF file.

    Build products:
        * ``{{name}}.rpt``: Yosys log.
        * ``{{name}}.json``: synthesized RTL.
        * ``{{name}}.tim``: nextpnr log.
        * ``{{name}}.fs``: ASCII bitstream.
    """

    toolchain = None # selected when creating platform

    device  = abstractproperty()
    package = abstractproperty()

    # Apicula templates

    _apicula_required_tools = [
        "yosys",
        "nextpnr-generic",
        "bash",
    ]
    _apicula_file_templates = {
        **TemplatedPlatform.build_script_templates,
        "{{name}}.il": r"""
            # {{autogenerated}}
            {{emit_rtlil()}}
        """,
        "{{name}}.debug.v": r"""
            /* {{autogenerated}} */
            {{emit_debug_verilog()}}
        """,
        "{{name}}.ys": r"""
            # {{autogenerated}}
            {% for file in platform.iter_extra_files(".v") -%}
                read_verilog {{get_override("read_verilog_opts")|options}} {{file}}
            {% endfor %}
            {% for file in platform.iter_extra_files(".sv") -%}
                read_verilog -sv {{get_override("read_verilog_opts")|options}} {{file}}
            {% endfor %}
            {% for file in platform.iter_extra_files(".il") -%}
                read_ilang {{file}}
            {% endfor %}
            read_ilang {{name}}.il
            {{get_override("script_after_read")|default("# (script_after_read placeholder)")}}
            tcl /home/konrad/dev/apicula/generic/synth/synth_generic.tcl 4
            {{get_override("script_after_synth")|default("# (script_after_synth placeholder)")}}
            write_json {{name}}.json
        """,
        "{{name}}.pcf": r"""
            # {{autogenerated}}
            {% for port_name, pin_name, attrs in platform.iter_port_constraints_bits() -%}
                set_io {{port_name}} {{pin_name}}
            {% endfor %}
            {% for net_signal, port_signal, frequency in platform.iter_clock_constraints() -%}
                set_frequency {{net_signal|hierarchy(".")}} {{frequency/1000000}}
            {% endfor%}
            {{get_override("add_constraints")|default("# (add_constraints placeholder)")}}
        """,
    }
    _apicula_command_templates = [
        r"""
        {{invoke_tool("yosys")}}
            {{quiet("-q")}}
            {{get_override("yosys_opts")|options}}
            -l {{name}}.rpt
            {{name}}.ys
        """,

        r"""

        DEVICE=GW1N-1 {{invoke_tool("nextpnr-generic")}}
            {{quiet("--quiet")}}
            {{get_override("nextpnr_opts")|options}}
            --log {{name}}.tim
            --pre-pack /home/konrad/dev/apicula/generic/simple.py
            --pre-place /home/konrad/dev/apicula/generic/simple_timing.py
            --json {{name}}.json
            --post-route /home/konrad/dev/apicula/generic/bitstream.py
            --write pnr{{name}}.json
#            --pcf {{name}}.pcf
        """,

        r"""
        {{invoke_tool("bash")}}
            -c "
                python3 /home/konrad/dev/apicula/gowin_pack.py pnr{{name}}.json {{name}}.fs
            "
        """,

        # r"""
        # {{invoke_tool("yosys")}}
        #     {{quiet("-q")}}
        #     -p "
        #         read_verilog -lib /home/konrad/dev/apicula/generic/synth/prims.v;
        #         read_json pnr{{name}}.json;
        #         dump -o {{name}}.debug.il;
        #         show -format png -prefix {{name}};
        #     "
        # """,

    ]

    # Common logic

    def __init__(self, *, toolchain="Apicula"):
        super().__init__()

        assert toolchain in ("Apicula")
        self.toolchain = toolchain

    @property
    def family(self):
        if self.device.startswith("GW1N"):
            return "GW1N"
        assert False

    @property
    def _toolchain_env_var(self):
        if self.toolchain == "Apicula":
            return f"NMIGEN_ENV_{self.toolchain}"
        assert False

    @property
    def required_tools(self):
        if self.toolchain == "Apicula":
            return self._apicula_required_tools
        assert False

    @property
    def file_templates(self):
        if self.toolchain == "Apicula":
            return self._apicula_file_templates
        assert False

    @property
    def command_templates(self):
        if self.toolchain == "Apicula":
            return self._apicula_command_templates
        assert False

    @property
    def default_clk_constraint(self):
        # TODO: Review this later

        # # Internal high-speed oscillator: 48 MHz / (2 ^ div)
        # if self.default_clk == "SB_HFOSC":
        #     return Clock(48e6 / 2 ** self.hfosc_div)
        # # Internal low-speed oscillator: 10 KHz
        # elif self.default_clk == "SB_LFOSC":
        #     return Clock(10e3)
        # # Otherwise, use the defined Clock resource.
        return super().default_clk_constraint

    def create_missing_domain(self, name):
        if name == "sync" and self.default_clk is not None:
            m = Module()

            # TODO: Add internal oscillators

            # User-defined clock signal.
            clk_i = self.request(self.default_clk).i
            delay = int(15e-6 * self.default_clk_frequency)

            if self.default_rst is not None:
                rst_i = self.request(self.default_rst).i
            else:
                rst_i = Const(0)

            # Power-on-reset domain
            m.domains += ClockDomain("por", reset_less=True, local=True)
            timer = Signal(range(delay))
            ready = Signal()
            m.d.comb += ClockSignal("por").eq(clk_i)
            with m.If(timer == delay):
                m.d.por += ready.eq(1)
            with m.Else():
                m.d.por += timer.eq(timer + 1)

            # Primary domain
            m.domains += ClockDomain("sync")
            m.d.comb += ClockSignal("sync").eq(clk_i)
            if self.default_rst is not None:
                m.submodules.reset_sync = ResetSynchronizer(~ready | rst_i, domain="sync")
            else:
                m.d.comb += ResetSignal("sync").eq(~ready)

            return m

    def should_skip_port_component(self, port, attrs, component):
        # TODO: Review this later
        return False
    def _get_xdr_buffer(self, m, pin, *, i_invert=False, o_invert=False):
        def get_ireg(clk, d, q):
            for bit in range(len(q)):
                m.d[clk] += d[bit].eq(q[bit])

        def get_oreg(clk, d, q):
            for bit in range(len(q)):
                m.d[clk] += d[bit].eq(q[bit])

        def get_ineg(z, invert):
            if invert:
                a = Signal.like(z, name_suffix="_n")
                m.d.comb += z.eq(~a)
                return a
            else:
                return z

        def get_oneg(a, invert):
            if invert:
                z = Signal.like(a, name_suffix="_n")
                m.d.comb += z.eq(~a)
                return z
            else:
                return a

        if "i" in pin.dir:
            if pin.xdr < 2:
                pin_i  = get_ineg(pin.i,  i_invert)
        if "o" in pin.dir:
            if pin.xdr < 2:
                pin_o  = get_oneg(pin.o,  o_invert)

        i = o = t = None
        if "i" in pin.dir:
            i = Signal(pin.width, name="{}_xdr_i".format(pin.name))
        if "o" in pin.dir:
            o = Signal(pin.width, name="{}_xdr_o".format(pin.name))
        if pin.dir in ("oe", "io"):
            t = Signal(1,         name="{}_xdr_t".format(pin.name))

        if pin.xdr == 0:
            if "i" in pin.dir:
                i = pin_i
            if "o" in pin.dir:
                o = pin_o
            if pin.dir in ("oe", "io"):
                t = ~pin.oe
        elif pin.xdr == 1:
            if "i" in pin.dir:
                get_ireg(pin.i_clk, i, pin_i)
            if "o" in pin.dir:
                get_oreg(pin.o_clk, pin_o, o)
            if pin.dir in ("oe", "io"):
                get_oreg(pin.o_clk, ~pin.oe, t)
        else:
            assert False

        return (i, o, t)

    def get_input(self, pin, port, attrs, invert):
        self._check_feature("single-ended input", pin, attrs,
                            valid_xdrs=(0, 1), valid_attrs=True)
        m = Module()
        i, o, t = self._get_xdr_buffer(m, pin, i_invert=invert)

        # Hack because we don't have PCF/LPF support yet
        resource_name = None
        for port_name, pin_name, attrs in self.iter_port_constraints_bits():
            if (port_name == port.name):
                resource_name = pin_name

        assert resource_name, f"resource {port.name} not found"

        for bit in range(len(port)):
            m.submodules["{}_{}".format(pin.name, bit)] = Instance("GENERIC_IOB",
                a_BEL=resource_name,
                p_INPUT_USED=1,
                p_OUTPUT_USED=0,
                i_I=port[bit],
                o_O=pin[bit]
            )
        return m

    def get_output(self, pin, port, attrs, invert):
        self._check_feature("single-ended output", pin, attrs,
                            valid_xdrs=(0, 1), valid_attrs=True)
        m = Module()
        # i, o, t = self._get_xdr_buffer(m, pin, o_invert=invert)

        # Hack because we don't have PCF/LPF support yet
        resource_name = None
        for port_name, pin_name, attrs in self.iter_port_constraints_bits():
            if (port_name == port.name):
                resource_name = pin_name

        assert resource_name, f"resource {port.name} not found"

        for bit in range(len(port)):
            m.submodules["{}_{}".format(pin.name, bit)] = Instance("GENERIC_IOB",
                a_BEL=resource_name,
                a_BEL_STRENGTH="5",
                p_INPUT_USED=0,
                p_OUTPUT_USED=1,
                i_I=pin[bit],
                o_O=port[bit]
            )
        return m

    def get_tristate(self, pin, port, attrs, invert):
        self._check_feature("single-ended tristate", pin, attrs,
                            valid_xdrs=(0, 1), valid_attrs=True)
        m = Module()
        i, o, t = self._get_xdr_buffer(m, pin, o_invert=invert)
        for bit in range(len(port)):
            m.submodules["{}_{}".format(pin.name, bit)] = Instance("GENERIC_IOB",
                p_INPUT_USED=1,
                p_OUTPUT_USED=1,
                i_T=t,
                i_I=o[bit],
                o_O=port[bit]
            )
        return m

    def get_input_output(self, pin, port, attrs, invert):
        self._check_feature("single-ended input/output", pin, attrs,
                            valid_xdrs=(0, 1), valid_attrs=True)
        m = Module()
        i, o, t = self._get_xdr_buffer(m, pin, i_invert=invert, o_invert=invert)
        for bit in range(len(port)):
            m.submodules["{}_{}".format(pin.name, bit)] = Instance("GENERIC_IOB",
                p_INPUT_USED=1,
                p_OUTPUT_USED=1,
                i_T=t,
                i_I=o[bit],
                o_O=port[bit]
            )
        return m

    def get_diff_input(self, pin, p_port, n_port, attrs, invert):
        return False

    def get_diff_output(self, pin, p_port, n_port, attrs, invert):
        return False

    def get_diff_tristate(self, pin, p_port, n_port, attrs, invert):
        return False

    def get_diff_input_output(self, pin, p_port, n_port, attrs, invert):
        return False
